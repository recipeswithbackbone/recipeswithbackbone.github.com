---
layout: backbone
title: Collection View
---
    <div id="inner-content">
      <div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a id="_collection_view"></a>Collection View</h2></div></div></div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_in_server_side_applications"></a>In server-side applications</h3></div></div></div>
<p>In server-side applications, it is common to see routes that represent many items of the same type.  For example, the <code class="literal">/tweets</code> route might display HTML for all of the tweets in the system.</p>
<p>Typically, this server-side code gathers up all <code class="literal">tweets</code> via a database query. It then iterates over each record, rendering them as HTML in a template.  This is all well and good when the following conditions are true:</p>
<div class="orderedlist"><ol type="1">
<li>
The server-side template library can handle iteration (or arbitrary code)
</li>
<li>
The generated page is not interactive
</li>
</ol></div>
<p>Unfortunately, neither of these conditions hold for interactive, client-side code.  Additionally, we encounter other obstacles:</p>
<div class="orderedlist"><ol type="1">
<li>
Maintaining client-side templates quickly grows disorganized and confusing when they are filled with logic and iteration
</li>
<li>
A lot of interactive code is concentrated into a few "master" views instead of spread throughout the models
</li>
</ol></div>
<p>The first point is immediately apparent for anyone who has worked on a large client-side application (otherwise, take our word for it!).  The second point is more subtle and will creep into your application over time.</p>
<p>Consider our <code class="literal">tweets</code> application, which might consist of:</p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="literal">Models.Tweets</code>
</li>
<li>
<code class="literal">Collections.Tweets</code>
</li>
<li>
<code class="literal">Views.Tweets</code>
</li>
<li>
<code class="literal">Templates.Tweets</code>
</li>
</ul></div>
<p>Think about what <code class="literal">Templates.Tweets</code> would look like.  One of the first lines will be the beginning of an iteration over individual <code class="literal">tweets</code>.  <span class="strong"><strong>The majority of this view will be concerned with rendering an individual <code class="literal">tweet</code></strong></span>.  This should immediately be an indicator that <code class="literal">Templates.Tweets</code> is not doing what it was designed to do.  A template for rendering multiple tweets should only be concerned with concepts like lists and ordering, not with the process of rendering individual items.</p>
<p>Additionally, if we have a master <code class="literal">TweetsView</code>, its event bindings will be on the <span class="emphasis"><em>list of tweets</em></span> not on the <span class="emphasis"><em>individual tweets</em></span>.  This will be much harder to implement naturally using Backbone’s event binding.</p>
<p>Furthermore, if an event is triggered signaling that an individual <code class="literal">tweet</code> has changed and must be re-rendered, we need to re-render the entire list of <code class="literal">tweets</code>.  This is not only expensive, but can jar the user’s view by breaking their scrolling position (if the list is long and they are in the middle).  It also means that a single view is listening to events triggered by many models, which is another code smell.</p>
<p>In well designed server-side applications, the <code class="literal">tweets</code> template will simply loop over the tweets and immediately render a <code class="literal">tweet</code> template for each one, thus delegating that work onto another class.  This is what we want to do in Backbone.  The difference is that, in Backbone, it is much simpler and more natural to have views call subviews, instead of having templates call subtemplates.</p>
</div>
<div class="section" lang="en" xml:lang="en">
<div class="titlepage"><div><div><h3 class="title">
<a id="_breaking_up_views_in_backbone"></a>Breaking up Views in Backbone</h3></div></div></div>
<p>First, we need a new application structure:</p>
<div class="itemizedlist"><ul type="disc">
<li>
<code class="literal">Models.Tweets</code>
</li>
<li>
<code class="literal">Collections.Tweets</code>
</li>
<li>
<code class="literal">Views.Tweets</code>
</li>
<li>
<code class="literal">Templates.Tweets</code>
</li>
<li>
<span class="strong"><strong><code class="literal">Views.Tweet</code></strong></span>
</li>
<li>
<span class="strong"><strong><code class="literal">Templates.Tweet</code></strong></span>
</li>
</ul></div>
<p>We have added a second view and second template to handle individual tweets.  Let’s take a look at what the top level <code class="literal">Templates.Tweets</code> and <code class="literal">Views.Tweets</code> might look like:</p>
<pre class="programlisting">Templates.Tweets = _.template("&lt;h2&gt;Here is a list of Tweets&lt;/h2&gt;");</pre>
<pre class="programlisting">Views.Tweets = Backbone.View.extend({
  template: Templates.Tweets,

  initialize: function(properties) {
    _.bindAll(this, 'render', 'addAll', 'addOne');
    this.collection.bind('add', this.addOne);
  },

  render: function() {
    $(this.el).html(this.template());
    addAll();
    return this;
  },

  addAll: function() {
    this.collection.each(this.addOne);
  },

  addOne: function(model) {
    view = new Views.Tweet(model);
    view.render();
    $(this.el).append(view.el);
    model.bind('remove', view.remove);
  }
});</pre>
<pre class="programlisting">// Create our view from a new collection and render
MyApplication.TweetsView = new Views.Tweets(new Collections.Tweets);
MyApplication.TweetsView.render();</pre>
<p>Here is what <code class="literal">Views.Tweets</code> is responsible for:</p>
<div class="orderedlist"><ol type="1">
<li>
Rendering its own template (the template data not relevant to individual tweets)
</li>
<li>
Iterating over <code class="literal">Collections.Tweets</code>
</li>
<li>
Creating new <code class="literal">Views.Tweet</code> when a new <code class="literal">tweet</code> is added to the collection and appending that view’s DOM element to its own
</li>
<li>
Asking the view to remove itself when the model is removed from the collection
</li>
</ol></div>
<p>More importantly, note what <code class="literal">Views.Tweets</code> is <span class="emphasis"><em>not</em></span> responsible for:</p>
<div class="orderedlist"><ol type="1">
<li>
Rendering individual <code class="literal">tweets</code>
</li>
<li>
Listening to events on individual <code class="literal">tweets</code>
</li>
<li>
Updating the individual <code class="literal">tweet</code> view
</li>
<li>
Removing the view when a model is destroyed
</li>
</ol></div>
<p>Now that we have that sorted out, let’s look at <code class="literal">Templates.Tweet</code> and <code class="literal">Views.Tweet</code>:</p>
<pre class="programlisting">Templates.Tweet = _.template("&lt;div class='author'&gt;&lt;%= author %&gt;&lt;/div&gt;" +
                             "&lt;div class='body'&gt;&lt;%= body %&gt;&lt;/div&gt;")</pre>
<div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Warning</h3>
<p>Try to keep javascript code out of templates.  It is a good habit to pass JSON to a template, not pass a full model to a template.  Avoid iteration by doing the iteration in the view and creating subviews.  Conditionals are subjective, if they are short it is OK, but as they grow, consider subtemplates or subviews.</p>
</div>
<pre class="programlisting">Views.Tweet = Backbone.View.extend({
  template: Templates.Tweet,

  initialize: function(properties) {
    _.bindAll(this, 'render', 'remove');
    this.model.bind('change', this.render);
    this.model.bind('destroy', this.remove);
  },

  render: function() {
    $(this.el).html(this.template(this.model.toJSON()));
    return this;
  },

  remove: function() {
    $(this.el).remove();
  }
})</pre>
<p>Here is what <code class="literal">Views.Tweet</code> is responsible for:</p>
<div class="orderedlist"><ol type="1">
<li>
Rendering an individual <code class="literal">tweet</code>
</li>
<li>
Updating the view when the <code class="literal">tweet</code> changes
</li>
<li>
Removing the view when the <code class="literal">tweet</code> is destroyed
</li>
</ol></div>
<p>An interesting distinction between the <code class="literal">destroy</code> and <code class="literal">remove</code> events can be observed here.  Both are causing the same effect in the view and in the DOM, but they are very different events!</p>
<p>The <code class="literal">destroy</code> event occurs when the model is deleted from the persistence system (the server, or client storage, <span class="emphasis"><em>etc.</em></span>).  For example, we could have a button on our view called "Delete".  Or, <span class="strong"><strong>more importantly</strong></span>, there could be a button on an entirely different part of our application that deletes models.</p>
<p>Consider a side-panel that has a button called "Remove all read tweets" that only removes <code class="literal">tweet</code> models if they have the <code class="literal">read</code> attribute set.  We could easily say, "when the delete button is clicked, remove this element".  If we do that, we would have to do that for every instance that a model is deleted in some way <span class="emphasis"><em>and</em></span> would need to hook it up to every view that displays that model.  The power of events in Backbone is that, by binding to relevant events, we can avoid this duplication.</p>
<p>We also need to be aware of <code class="literal">remove</code> actions, because we may be maintaining multiple collections with the same set of models in them.  Consider if we had all our tweets in a global <code class="literal">MyApplication.Tweets</code>, but then we created two sub-collections: <code class="literal">MyApplication.ReadTweets</code> and <code class="literal">MyApplication.UnreadTweets</code>. Any time a <code class="literal">Model.Tweet</code> was marked as <code class="literal">read</code> or <code class="literal">unread</code>, we move it from one collection to the other.  In memory, those are the same <code class="literal">Model.Tweet</code> in the top-level <code class="literal">MyApplication.Tweets</code> and in the sub-collections.</p>
<p>If we had a <code class="literal">Views.Tweets</code> for each of the sub-collections, we need to remove the view elements on a <code class="literal">remove</code> event, but the model is not deleted, just removed from the collection.  Since this is a Collection View we are representing the state of the collection, and must modify the view to mirror the collection’s state.</p>
<div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;">
<h3 class="title">Tip</h3>
<p>Always try to use the most appropriate event when binding to an action. Don’t see the right event?  We will cover firing and listening to custom events in a later chapter.</p>
</div>
</div>
</div>

    </div>

